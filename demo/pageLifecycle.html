<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0,user-scalable=no,viewport-fit=cover,minimal-ui">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="apple-mobile-web-app-capable" content="yes">

    <title>Page Lifecycle</title>
</head>
<body>
<h1>Page Lifecycle API  [网页从诞生到卸载的行为模式]</h1>
<p>功能：定义了新的事件，允许开发者响应网页状态的各种转换</p>
<p>兼容性： chrome68支持这个API, 老浏览器可以使用谷歌开发的兼容库</p>
<article>
    网页生命的周期分为六个阶段。
    active  +  passive  + hidden + terminated  +  frozen + discarded

    <h2>MVP模式  model-view-presenter</h2>
    <p>mvp的全称为Model-View-Presenter，Model提供数据，View负责显示，Controller/Presenter负责逻辑的处理。
        MVP与MVC有着一个重大的区别：
        在MVP中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，
        而在MVC中View会直接从Model中读取数据而不是通过 Controller</p>
    <p>
        在MVP里，Presenter完全把Model和View进行了分离，主要的程序逻辑在Presenter里实现。
        而且，Presenter与具体的View是没有直接关联的，而是通过定义好的接口进行交互，从而使得在变更View时候可以保持Presenter的不变，即重用！
        不仅如此，我们还可以编写测试用的View，模拟用户的各种操作，从而实现对Presenter的测试--而不需要使用自动化的测试工具。
        我们甚至可以在Model和View都没有完成时候，就可以通过编写Mock Object（即实现了Model和View的接口，但没有具体的内容的）来测试Presenter的逻辑。
        在MVP里，应用程序的逻辑主要在Presenter来实现，其中的View是很薄的一层。
        因此就有人提出了Presenter First的设计模式，就是根据User Story来首先设计和开发Presenter。
        在这个过程中，View是很简单的，能够把信息显示清楚就可以了。在后面，根据需要再随便更改View，而对Presenter没有任何的影响了。
        如果要实现的UI比较复杂，而且相关的显示逻辑还跟Model有关系，就可以在View和Presenter之间放置一个Adapter。 由这个 Adapter来访问Model和View，避免两者之间的关联。
        而同时，因为Adapter实现了View的接口，从而可以保证与Presenter之间接口的不变。这样就可以保证View和Presenter之间接口的简洁，又不失去UI的灵活性。
        在MVP模式里，View只应该有简单的Set/Get的方法，用户输入和设置界面显示的内容，除此就不应该有更多的内容，绝不容许直接访问Model--这就是与MVC很大的不同之处。

    </p>
</article>
</body>
</html>